{
    int8_t r;

uint16_t count=0;
    
	// set for 16 MHz clock
	CPU_PRESCALE(0);
    
	// Initialize the USB, and then wait for the host to set configuration.
	// If the Teensy is powered without a PC connected to the USB port,
	// this will wait forever.
	usb_init();
	while (!usb_configured()) /* wait */ ;
    
	// Wait an extra second for the PC's operating system to load drivers
	// and do whatever it does to actually be ready for input
	_delay_ms(1000);

	//in Start-loop in while
	//init_twi_slave (SLAVE_ADRESSE);
	sei();
	
	
	slaveinit();
		
	/* initialize the LCD */
	lcd_initialize(LCD_FUNCTION_8x2, LCD_CMD_ENTRY_INC, LCD_CMD_ON);

	lcd_puts("Guten Tag\0");
	delay_ms(100);
	lcd_cls();
	//lcd_puts("READY\0");
	lcd_puts("V: \0");
	lcd_puts(VERSION);
   lcd_clr_line(1);

	uint8_t Tastenwert=0;
	uint8_t TastaturCount=0;
	
	uint16_t TastenStatus=0;
	uint16_t Tastencount=0;
	uint16_t Tastenprellen=0x01F;
	//timer0();
	
	//initADC(TASTATURPIN);
	//wdt_enable(WDTO_2S);
	
	uint16_t loopcount0=0;
	uint8_t loopcount1=0;

	
	
	
	/*
	Bit 0: 1 wenn wdt ausgel√∂st wurde
	 
	  */ 
	uint8_t i=0;
   
	//timer2
	TCNT2   = 0; 
//	TCCR2A |= (1 << WGM21);    // Configure timer 2 for CTC mode 
	TCCR2B |= (1 << CS20);     // Start timer at Fcpu/8 
//	TIMSK2 |= (1 << OCIE2A);   // Enable CTC interrupt 
	TIMSK2 |= (1 << TOIE2);    // Enable OV interrupt 
	//OCR2A   = 5;             // Set CTC compare value with a prescaler of 64 
    TCCR2A = 0x00;

	  sei();
   
   PWM = 0;
   
   char* versionstring = (char*) malloc(4);
   strncpy(versionstring, VERSION+9, 3);
   versionstring[3]='\0';
   volatile uint16_t versionint = atoi(versionstring);
   volatile uint8_t versionintl = versionint & 0x00FF;
   //versionint >>=8;
   volatile uint8_t versioninth = (versionint & 0xFF00)>>8;
   
   
// MARK: mark while	  
	while (1)
	{
      
      //OSZIBLO;
		//Blinkanzeige
		loopcount0+=1;
		if (loopcount0==0xAFFF)
		{
			loopcount0=0;
			loopcount1+=1;
			LOOPLEDPORT ^=(1<<LOOPLED);
         PORTD ^= (1<<PORTD6);
			//
			//STEPPERPORT_1 ^= (1 << MA_STEP);
			//PORTD ^= (1<<0);
			//lcd_gotoxy(18,1);
			//lcd_puthex(loopcount1);
			//timer0();
		} // if loopcount
      
      /**	HOT	***********************/
      /*
       pwmposition wird in der ISR incrementiert. Wenn pwmposition > ist als der eingestellte Wert PWM, wird der Impuls wieder abgeschaltet. Nach dem Overflow wird wieder eingeschaltet
       */
      
      
      if (PWM) // Draht soll heiss sein, PWM >0. 
      {
         
         if (pwmposition > PWM) // > DC OFF, PIN ist LO
         {
            CMD_PORT &= ~(1<<DC);
            //OSZIAHI ;
         }
         else                    // > DC ON, PIN ist HI
         {
            CMD_PORT |= (1<<DC); // DC ON
            //OSZIALO ;
            
         }
         
      }
      else
      {
         CMD_PORT &= ~(1<<DC); // Draht ausschalten
      }

		
// MARK: mark start_usb
       /**	Begin USB-routinen	***********************/
      
        // Start USB
      //lcd_putc('u');
      r = usb_rawhid_recv((void*)buffer, 0);
		if (r > 0) 
      {
         //OSZIBHI;
         cli(); 
         
         uint8_t code = 0x00;
         code = buffer[16];
         switch (code)
         {   
               
            case 0xE0: // Man: Alles stoppen
            {
               ringbufferstatus = 0;
               motorstatus=0;
               anschlagstatus = 0;
               cncstatus = 0;
               sendbuffer[0]=0xE1;
               
               sendbuffer[5]=abschnittnummer;
               sendbuffer[6]=ladeposition;
               usb_rawhid_send((void*)sendbuffer, 50);
               sei();
               sendbuffer[0]=0x00;
               sendbuffer[5]=0x00;
               sendbuffer[6]=0x00;
               ladeposition=0;
               endposition=0xFFFF;
               
               AbschnittCounter=0;
               PWM = sendbuffer[20];
               CMD_PORT &= ~(1<<DC);
               
               
               StepCounterA=0;
               StepCounterB=0;
               StepCounterC=0;
               StepCounterD=0;
               
               CounterA=0;
               CounterB=0;
               CounterC=0;
               CounterD=0;
               
               STEPPERPORT_1 |= (1<<MA_EN); // Pololu OFF
               STEPPERPORT_1 |= (1<<MB_EN); // Pololu OFF
               STEPPERPORT_2 |= (1<<MC_EN); // Pololu OFF
               STEPPERPORT_2 |= (1<<MD_EN); // Pololu OFF
 
               lcd_gotoxy(0,1);
               lcd_puts("HALT\0");
               
            }break;
               
               
            case 0xE2: // DC ON_OFF: Temperatur Schneiddraht setzen
            {
               PWM = buffer[20];
               if (PWM==0)
               {
                  CMD_PORT &= ~(1<<DC);
               }
               
                
            }break;
               
               
            case 0xE4: // Stepperstrom ON_OFF
            {
               
               if (buffer[8]) // 
               {
                  CMD_PORT |= (1<<STROM); // ON
                  PWM = buffer[20];
               }
               else
               {
                  CMD_PORT &= ~(1<<STROM); // OFF
                  PWM = 0;
               }
               
               if (PWM==0)
               {
                  CMD_PORT &= ~(1<<DC);
               }
               
                 
            }break;
               
            case 0xE6:  // mousup
            {
               CounterA = 0;
               CounterB = 0;
               ringbufferstatus = 0;
               cncstatus=0;
               motorstatus=0;
               StepCounterA=0;
               CounterA=0;
               AbschnittCounter=0;
               
            }break;
               
            case 0xF1: // reset
            {
               uint8_t i=0, k=0;
               for (k=0;k<RINGBUFFERTIEFE;k++)
               {
                  for(i=0;i<USB_DATENBREITE;i++)
                  {
                     CNCDaten[k][i]=0;  
                  }
               }
               
               ringbufferstatus = 0;
               motorstatus=0;
               anschlagstatus = 0;
               
               cncstatus = 0;
               ladeposition=0;
               endposition=0xFFFF;
               
               AbschnittCounter=0;
               PWM = 0;
               CMD_PORT &= ~(1<<DC);
               
               
               StepCounterA=0;
               StepCounterB=0;
               StepCounterC=0;
               StepCounterD=0;
               
               CounterA=0;
               CounterB=0;
               CounterC=0;
               CounterD=0;
               
               lcd_gotoxy(0,1);
               lcd_puts("reset\0");
               //cli();
               //usb_init();
               /*
                while (!usb_configured()) // wait  ;
                
                // Wait an extra second for the PC's operating system to load drivers
                // and do whatever it does to actually be ready for input
                _delay_ms(1000);
                */
               //sei();
               //sendbuffer[0]=0xF2;
               //usb_rawhid_send((void*)sendbuffer, 50);
               //sendbuffer[0]=0x00;
               
            }break;
// MARK: mark default
            default:
            {
               // Abschnittnummer bestimmen
               uint8_t indexh=buffer[18];
               uint8_t indexl=buffer[19];
               uint8_t position = buffer[17];
               
               
               abschnittnummer= indexh<<8;
               abschnittnummer += indexl;
               sendbuffer[0]=0x33;
               sendbuffer[5]=abschnittnummer;
               sendbuffer[6]=buffer[16];
               
    //           sendbuffer[8]= versionintl;
    //           sendbuffer[9]= versioninth;
               
               
              
 //              usb_rawhid_send((void*)sendbuffer, 50); // nicht jedes Paket melden
               
               if (abschnittnummer==0)
               {
                //  lcd_clr_line(1);
                  cli();
                  /*
                  uint8_t i=0,k=0;
                  for (k=0;k<RINGBUFFERTIEFE;k++)
                  {
                     for(i=0;i<USB_DATENBREITE;i++)
                     {
                        CNCDaten[k][i]=0;  
                     }
                  }
                   */
                  //CNCDaten = {};
                  
                  
                  ladeposition=0;
                  endposition=0xFFFF;
                  cncstatus = 0;
                  motorstatus = 0;
                  ringbufferstatus=0x00;
                  anschlagstatus=0;
                  ringbufferstatus |= (1<<FIRSTBIT);
                  AbschnittCounter=0;
                  //sendbuffer[8]= versionintl;
                  //sendbuffer[8]= versioninth;
                  sendbuffer[5]=0x00;
                  
                  //in teensy3.2: timerintervall
  //                sendbuffer[8] = (TIMERINTERVALL & 0xFF00)>>8;
  //                sendbuffer[9] = (TIMERINTERVALL & 0x00FF);
                  sendbuffer[0]=0xD1;
                   
                  if (code == 0xF0) // cncstatus fuer go_home setzen
                  {
                     sendbuffer[5]=0xF0;
                     sendbuffer[0]=0x45;
                     cncstatus |= (1<<GO_HOME); // Bit fuer go_home setzen
                  }
                  else  if (code == 0xF1) // neu 200606
                  {
                     sendbuffer[0]=0x44;
                     cncstatus &= ~(1<<GO_HOME); // Bit fuer go_home zuruecksetzen
                  }
        //         usb_rawhid_send((void*)sendbuffer, 50);
                  startTimer2();
                  sei();
                  
               }
               else
               {
                  
               }
               
               //             if (buffer[9]& 0x02)// letzter Abschnitt
               
               if (buffer[17]& 0x02)// letzter Abschnitt
               {
                  ringbufferstatus |= (1<<LASTBIT);
                  if (ringbufferstatus & (1<<FIRSTBIT)) // nur ein Abschnitt
                  {
                     endposition=abschnittnummer; // erster ist letzter Abschnitt
                  }
               }
               
               
               
               // Daten vom buffer in CNCDaten laden
               {
                  uint8_t pos=(abschnittnummer);
                  pos &= 0x03; // 2 bit // Beschraenkung des index auf Buffertiefe 
                  //if (abschnittnummer>8)
                  {
                     //lcd_putint1(pos);
                  }
                  uint8_t i=0;
                  for(i=0;i<USB_DATENBREITE;i++)
                  {
                     CNCDaten[pos][i]=buffer[i];  
                  }
                  
               }
               
               
               // Erster Abschnitt, naechsten Abschnitt laden
               if ((abschnittnummer == 0)&&(endposition))
               {
                  {
                     //lcd_putc('*');
                     // Version zurueckmelden
                     
                     int versionl, versionh;
                     
                     //versionl=VERSION & 0xFF;
                     //versionh=((VERSION >> 8) & 0xFF);

                     
                     
                     
                     
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                     sendbuffer[0]=0xAF;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     sei();
                     //  sendbuffer[0]=0x00;
                     //  sendbuffer[5]=0x00;
                     //  sendbuffer[6]=0x00;
                     
                     
                  }  
               }
               
               ringbufferstatus &= ~(1<<FIRSTBIT);
               
               // Ringbuffer ist voll oder  letzter Abschnitt schon erreicht
               //if ((abschnittnummer >= 2)||(ringbufferstatus & (1<<LASTBIT)))                {
               if ((abschnittnummer ==1 )||((abschnittnummer ==0 )&&(ringbufferstatus & (1<<LASTBIT)))) 
               {
                  {
                     ringbufferstatus &= ~(1<<LASTBIT);
                     ringbufferstatus |= (1<<STARTBIT);
                     
                  }
               }
               
            } // default
               
         } // switch code
         code=0;
         sei();
         
		} // r>0, neue Daten
      
      /**	End USB-routinen	***********************/
      
		/**	Start CNC-routinen	***********************/
      
      if (ringbufferstatus & (1<<STARTBIT)) // Buffer ist geladen, Abschnitt 0 laden
      {
         cli();
         ringbufferstatus &= ~(1<<STARTBIT);         
         ladeposition=0;
         AbschnittCounter=0;
         // Ersten Abschnitt laden
         for(i=0;i<USB_DATENBREITE;i++)
         {
  //          CNCDaten[0][i]=0;  
         }

         uint8_t pos=AbschnittLaden_4M(CNCDaten[0]); 
         ladeposition++;
         if (pos==2) // nur ein Abschnitt
         {
            ringbufferstatus |=(1<<ENDBIT);
            ringbufferstatus |=(1<<LASTBIT);
         }
         
         AbschnittCounter+=1;
         sei();
      }
       
      /*
      // Anschlag A0
        if ((CMD_PIN & (1<< END_A0_PIN)) ) // Schlitten nicht am Anschlag A0
        {
            cncstatus &= ~(1<< END_A0); // Bit fuer Anschlag A0 zuruecksetzen
        }
        else                            // Schlitten am Anschlag A0
        {
            if (richtung & (1<<RICHTUNG_A)) // Richtung ist von Anschlag A0 weg, nichts tun
            {
               //lcd_putc(' ');
                cncstatus &= ~(1<< END_A0); // Bit fuer Anschlag A0 zuruecksetzen
            }
            else
            {
               //lcd_putc('a');
                cncstatus |= (1<< END_A0);      // Bit fuer Anschlag A0 setzen
                motorstatus &= ~(1<< COUNT_A);    // Motor A als relevant zuruecksetzen
                motorstatus |= (1<< COUNT_B);     // Motor B als relevant setzen
            }
        }
      
      // Anschlag B0     
      if ((CMD_PIN & (1<< END_B0_PIN)) ) // Schlitten nicht am Anschlag A1
      {
         cncstatus &= ~(1<< END_B0); // Bit fuer Anschlag A1 zuruecksetzen
      }
      else                            // Schlitten am Anschlag A1
      {
         if (richtung & (1<<RICHTUNG_B)) // Richtung ist auf Anschlag A1 zu, 
         {
            cncstatus |= (1<< END_B0);      // Bit fuer Anschlag B0 setzen
            motorstatus &= ~(1<< COUNT_B);    // Motor B als relevant zuruecksetzen
            motorstatus |= (1<< COUNT_A);     // Motor A als relevant setzen

            //lcd_putc(' ');
         }
         else // Richtung ist von  Anschlag A1 weg, nichts tun
         {
            cncstatus &= ~(1<< END_B0); // Bit fuer Anschlag A1 zuruecksetzen
           //lcd_putc('a');
         }
      }
      // End Anschlag B0
       

      */
      
// MARK: mark Anschlag
      // ********************
      // * Anschlag Motor A *
      // ********************
      
      if ((STEPPERPIN_1 & (1<< END_A0_PIN)) ) // Eingang ist HI, Schlitten nicht am Anschlag A0
      {
         if (anschlagstatus &(1<< END_A0))
         {
            anschlagstatus &= ~(1<< END_A0); // Bit fuer Anschlag A0 zuruecksetzen
         }
      }
      else // Schlitten bewegte sich auf Anschlag zu und ist am Anschlag A0
      {         
         AnschlagVonMotor(0);
      }
      
      // **************************************
      // * Anschlag Motor B *
      // **************************************
      // Anschlag B0
      if ((STEPPERPIN_1 & (1<< END_B0_PIN)) ) // Schlitten nicht am Anschlag B0
      {
         if (anschlagstatus &(1<< END_B0))
         {
            anschlagstatus &= ~(1<< END_B0); // Bit fuer Anschlag B0 zuruecksetzen
         }
      }
      else // Schlitten bewegte sich auf Anschlag zu und ist am Anschlag B0
      {
         AnschlagVonMotor(1);
      } // end Anschlag B0
      
      // End Anschlag B
      
      
      // ********************
      // * Anschlag Motor C *
      // ********************
      
      // Anschlag C0
      if ((STEPPERPIN_2 & (1<< END_C0_PIN)) ) // Eingang ist HI, Schlitten nicht am Anschlag C0
      {
         if (anschlagstatus &(1<< END_C0))
         {
            anschlagstatus &= ~(1<< END_C0); // Bit fuer Anschlag C0 zuruecksetzen
         }         
      }
      else // Schlitten bewegte sich auf Anschlag zu und ist am Anschlag C0
      {
         AnschlagVonMotor(2);
      }
      
      // ***************
      // * Anschlag Motor D *
      // ***************
      
      // Anschlag D0
      if ((STEPPERPIN_2 & (1<< END_D0_PIN)) ) // Schlitten nicht am Anschlag D0
      {
         if (anschlagstatus &(1<< END_D0))
         {
            anschlagstatus &= ~(1<< END_D0); // Bit fuer Anschlag D0 zuruecksetzen
         }
      }
      else // Schlitten bewegte sich auf Anschlag zu und ist am Anschlag D0
      {
         AnschlagVonMotor(3);
      }

// MARK: mark Motor A    
      // Begin Motor A
      // **************************************
      // * Motor A *
      // **************************************
   
      // Es hat noch Steps, CounterA ist abgezaehlt (DelayA bestimmt Impulsabstand fuer Steps)
            if (StepCounterA &&(CounterA == 0) &&(!(anschlagstatus & (1<< END_A0))))//||(cncstatus & (1<< END_B0)))))//	
            {
                cli();
               // Impuls starten
               STEPPERPORT_1 &= ~(1<<MA_STEP);   // Impuls an Motor A LO -> ON
               CounterA = DelayA;                     // CounterA zuruecksetzen fuer neuen Impuls
               
               StepCounterA--;
               
               // Wenn StepCounterA abgelaufen und relevant: next Datenpaket abrufen
               if (StepCounterA == 0 && (motorstatus & (1<< COUNT_A)))    // Motor A ist relevant fuer Stepcount
               {
                  
  //                STEPPERPORT_1 |= (1<<MA_EN);                          // Motor A OFF
                  //STEPPERPORT_2 |= (1<<MC_EN);
                  //StepCounterB=0; 
                  
                  //
                  /*
                  StepCounterA=0;
                  StepCounterB=0;
                  StepCounterC=0;
                  StepCounterD=0;
                  
                  CounterA=0;
                  CounterB=0;
                  CounterC=0;
                  CounterD=0;
                   */
                  //
                  // Begin Ringbuffer-Stuff
                  //if (ringbufferstatus & (1<<ENDBIT))
                  if (abschnittnummer==endposition) // Abschnitt fertig
                  {  
                     cli();
                     ringbufferstatus = 0;
                     cncstatus=0;
                     motorstatus=0;
                     sendbuffer[0]=0xAD;
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
 //                    sendbuffer[7]=(ladeposition & 0xFF00) >> 8;
                     sendbuffer[8] = cncstatus;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     ladeposition=0;
                     sei();
                  }
                  else 
                  {
                     uint8_t aktuellelage=0; // Lage innerhalb der Abschnittserie: Start: 1, Innerhalb: 0, Ende: 2
                     
                     uint8_t aktuelleladeposition=(ladeposition & 0x00FF);
                     aktuelleladeposition &= 0x03;
                     
                     // aktuellen Abschnitt laden
                      aktuellelage = AbschnittLaden_4M(CNCDaten[aktuelleladeposition]);
                     if (aktuellelage==2) // war letzter Abschnitt
                     {
                        endposition=abschnittnummer; // letzter Abschnitt
                        
                        // Neu: letzten Abschnitt melden
                        sendbuffer[0]=0xD0;
                        sendbuffer[5]=abschnittnummer;
                        sendbuffer[6]=ladeposition;
                        //sendbuffer[7]=(ladeposition & 0xFF00) >> 8;
                        sendbuffer[8] = cncstatus;
                        usb_rawhid_send((void*)sendbuffer, 50);
                        sei();
                        
                     }
                     else
                     {
                        // neuen Abschnitt abrufen
                        sendbuffer[5]=abschnittnummer;
                        sendbuffer[6]=ladeposition;
                        //sendbuffer[7]=(ladeposition & 0xFF00) >> 8;
                        sendbuffer[8] = cncstatus;
                        sendbuffer[0]=0xA1;
                        usb_rawhid_send((void*)sendbuffer, 50);
                     }
                     
                     ladeposition++;
                     
                     
                     
                     
                     if (aktuellelage==2)
                     {
                        //ringbufferstatus |= (1<<ENDBIT);
                     }
                     AbschnittCounter++;
                     
                  }
                  
               }
               
               sei();
            }
            else
            {
                STEPPERPORT_1 |= (1<<MA_STEP);					// Impuls an Motor A HI -> OFF
                
                if (StepCounterA ==0)							// Keine Steps mehr fuer Motor A
                {
                    STEPPERPORT_1 |= (1<<MA_EN);                     // Motor A OFF
                }
            }
          
        
       /*     
            // Halt-Pin
        else if (!(richtung & (1<<RICHTUNG_A)))
        {
            DelayA = 0;
            StepCounterA = 0;
            STEPPERPORT_1 |= (1<<MA_STEP);     // StepCounterA beenden
            STEPPERPORT_1 |= (1<<MA_EN);
            CounterA=0;
            
        }
        */
      // MARK: mark Motor B
      // **************************************
      // * Motor B *
      // **************************************
      
		if (StepCounterB && (CounterB == 0)&&(!(anschlagstatus & (1<< END_B0))))
		{
         cli();
         //lcd_putc('B');
         
			STEPPERPORT_1 &= ~(1<<MB_STEP);					// Impuls an Motor B LO ON
			CounterB = DelayB;
			StepCounterB--;
         
			if (StepCounterB ==0 && (motorstatus & (1<< COUNT_B))) // Motor B ist relevant fuer Stepcount 
			{
//				STEPPERPORT_1 |= (1<<MB_EN);					// Motor B OFF
				
            //StepCounterA=0;
            //lcd_putc('-');
            // Begin Ringbuffer-Stuff
            if (abschnittnummer==endposition)
            {  
               cli();
               
               ringbufferstatus = 0;
               cncstatus=0;
               motorstatus=0;
               sendbuffer[0]=0xAD;
               sendbuffer[1]=abschnittnummer;
               usb_rawhid_send((void*)sendbuffer, 50);
               ladeposition=0;
               sei();
            }
            else 
            { 
               uint8_t aktuellelage=0;
               {
                  uint8_t aktuelleladeposition=(ladeposition & 0x00FF);
                  aktuelleladeposition &= 0x03;
 
                  // aktuellen Abschnitt laden
                  aktuellelage = AbschnittLaden_4M(CNCDaten[aktuelleladeposition]);
                  if (aktuellelage==2) // war letzter Abschnitt
                  {
                      endposition=abschnittnummer; // letzter Abschnitt
                     // Neu: letzten Abschnitt melden
                     sendbuffer[0]=0xD0;
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                    // sendbuffer[7]=(ladeposition & 0xFF00) >> 8;
                     sendbuffer[8] = cncstatus;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     sei();
                  }  
                  else
                  {
                     // neuen Abschnitt abruffen
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                    // sendbuffer[7]=(ladeposition & 0xFF00) >> 8;
                     sendbuffer[8] = cncstatus;
                     sendbuffer[0]=0xA1;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     sei();
                  }
                  
                  ladeposition++;
               }
               if (aktuellelage==2)
               {
                  //ringbufferstatus |= (1<<ENDBIT);
               }
               AbschnittCounter++;
            }
         }
			sei();
		}
		else// if (CounterB)
		{
			STEPPERPORT_1 |= (1<<MB_STEP);
			if (StepCounterB ==0)							// Keine Steps mehr fuer Motor B
			{
				STEPPERPORT_1 |= (1<<MB_EN);					// Motor B OFF
                
			}
			
			
			
		}
		sei(); 
      
      // End Motor B
      
      // Begin Motor C
// MARK: mark Motor C
      // **************************************
      // * Motor C *
      // **************************************
      
      // Es hat noch Steps, CounterC ist abgezaehlt (DelayA bestimmt Impulsabstand fuer Steps)
      if (StepCounterC &&(CounterC == 0) &&(!(anschlagstatus & (1<< END_C0))))//||(cncstatus & (1<< END_D0)))))//	
      {
         cli();
         // Impuls starten
         STEPPERPORT_2 &= ~(1<<MC_STEP);   // Impuls an Motor C LO -> ON
         CounterC=DelayC;                     // CounterA zuruecksetzen fuer neuen Impuls
          
         StepCounterC--;
         
         // Wenn StepCounterC abgelaufen und relevant: next Datenpaket abrufen
         if (StepCounterC ==0 && (motorstatus & (1<< COUNT_C)))    // Motor A ist relevant fuer Stepcount 
         {
            
//            STEPPERPORT_2 |= (1<<MC_EN);                          // Motor C OFF
            //StepCounterD=0; 
            
            // Begin Ringbuffer-Stuff
            //if (ringbufferstatus & (1<<ENDBIT))
            if (abschnittnummer==endposition)
            {  
               cli();
               
               ringbufferstatus = 0;
               cncstatus=0;
               motorstatus=0;
               sendbuffer[0]=0xAD;
               sendbuffer[5]=abschnittnummer;
               sendbuffer[6]=ladeposition;
               sendbuffer[8] = cncstatus;
               usb_rawhid_send((void*)sendbuffer, 50);
               ladeposition=0;
               sei();
            }
            else 
            { 
               uint8_t aktuellelage=0; // Lage innerhalb der Abschnittserie: Start: 1, Innerhalb: 0, Ende: 2
               {
                  uint8_t aktuelleladeposition=(ladeposition & 0x00FF);
                  aktuelleladeposition &= 0x03;
  
                  // aktuellen Abschnitt laden

                  if (ladeposition>8)
                  {
                     //lcd_putint1(ladeposition);
                  }
                  aktuellelage = AbschnittLaden_4M(CNCDaten[aktuelleladeposition]);
                  if (aktuellelage==2) // war letzter Abschnitt
                  {
                     endposition=abschnittnummer; // letzter Abschnitt
                     // Neu: letzten Abschnitt melden
                     sendbuffer[0]=0xD0;
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                     sendbuffer[8] = cncstatus;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     sei();

                  }  
                  else
                  {
                     // neuen Abschnitt abrufen
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                     sendbuffer[8] = cncstatus;
                     sendbuffer[0]=0xA2;
                     usb_rawhid_send((void*)sendbuffer, 50);  
                     
                  }
                  
                  ladeposition++;
                  
               }
               
               
               if (aktuellelage==2)
               {
                  //ringbufferstatus |= (1<<ENDBIT);
               }
               AbschnittCounter++;
               
            }
            
         }
         
         sei();
      }
      else
      {
         STEPPERPORT_2 |= (1<<MC_STEP);					// Impuls an Motor C HI -> OFF
         
         if (StepCounterC ==0)							// Keine Steps mehr fuer Motor C
         {
            STEPPERPORT_2 |= (1<<MC_EN);                     // Motor C OFF
         }
      }
     
      // MARK: mark Motor D
        // **************************************
      // * Motor D *
      // **************************************
      
		if (StepCounterD && (CounterD == 0)&&(!(anschlagstatus & (1<< END_D0))))
		{
         cli();
         
			STEPPERPORT_2 &= ~(1<<MD_STEP);					// Impuls an Motor D LO: ON
			CounterD= DelayD;
			StepCounterD--;
         
			if (StepCounterD ==0 && (motorstatus & (1<< COUNT_D))) // Motor D ist relevant fuer Stepcount 
			{
//				STEPPERPORT_2 |= (1<<MD_EN);					// Motor D OFF
				
            //StepCounterC=0;
            // Begin Ringbuffer-Stuff
            if (abschnittnummer==endposition)
            {  
               cli();
               
               ringbufferstatus = 0;
               cncstatus=0;
               motorstatus=0;
               sendbuffer[0]=0xAD;
               sendbuffer[1]=abschnittnummer;
               usb_rawhid_send((void*)sendbuffer, 50);
               ladeposition=0;
               sei();
            }
            else 
            { 
               uint8_t aktuellelage=0;
               {
                  uint8_t aktuelleladeposition=(ladeposition & 0x00FF);
                  aktuelleladeposition &= 0x03;
                  
                  // aktuellen Abschnitt laden
                  
                  aktuellelage = AbschnittLaden_4M(CNCDaten[aktuelleladeposition]);
                  if (aktuellelage==2) // war letzter Abschnitt
                  {
                     endposition=abschnittnummer; // letzter Abschnitt
                     // Neu: letzten Abschnitt melden
                     sendbuffer[0]=0xD0;
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                     sendbuffer[8] = cncstatus;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     sei();

                  }  
                  else
                  {
                     // neuen Abschnitt abruffen
                     sendbuffer[5]=abschnittnummer;
                     sendbuffer[6]=ladeposition;
                     sendbuffer[8] = cncstatus;
                     sendbuffer[0]=0xA3;
                     usb_rawhid_send((void*)sendbuffer, 50);
                     
                  }
                  
                  ladeposition++;
                  
               }
               if (aktuellelage==2)
               {
                  //ringbufferstatus |= (1<<ENDBIT);
               }
               AbschnittCounter++;
               
            }
         }
			
			
			sei();
		}
		else// if (CounterB)
		{
			STEPPERPORT_2 |= (1<<MD_STEP);
			if (StepCounterD ==0)							// Keine Steps mehr fuer Motor D
			{
				STEPPERPORT_2 |= (1<<MD_EN);					// Motor D OFF
            
			}
			
			
			
		}
		sei(); 
      // End Motor D
		
   
		/**	Ende CNC-routinen	***********************/
		
		
		/* **** rx_buffer abfragen **************** */
		//rxdata=0;
		
// MARK: mark Tasten		
		//	Daten von USB vorhanden
		 // rxdata
		
		//lcd_gotoxy(16,0);
        //lcd_putint(StepCounterA & 0x00FF);
		
		if (!(TASTENPIN & (1<<TASTE0))) // Taste 0
		{
			//lcd_gotoxy(8,1);
			//lcd_puts("T0 Down\0");
			
			if (!(TastenStatus & (1<<TASTE0))) //Taste 0 war noch nicht gedrueckt
			{
				//RingD2(5);
				TastenStatus |= (1<<TASTE0);
				
				Tastencount=0;
				//lcd_gotoxy(0,1);
				//lcd_puts("P0 \0");
				//lcd_putint(TastenStatus);
				//delay_ms(800);
			}
			else
			{
				
				
				Tastencount +=1;
				//lcd_gotoxy(7,1);
				//lcd_puts("TC \0");
				//lcd_putint(Tastencount);
				
				if (Tastencount >= Tastenprellen)
				{
               
					Tastencount=0;
               if (TastenStatus & (1<<TASTE0))
               {
                  //sendbuffer[0]=loopcount1;
                  //sendbuffer[1]=0xAB;
                  //usbstatus |= (1<<USB_SEND);
                  //lcd_gotoxy(2,1);
                  //lcd_putc('1');

                  //usb_rawhid_send((void*)sendbuffer, 50);
               }
					TastenStatus &= ~(1<<TASTE0);
               //lcd_gotoxy(3,1);
               //lcd_puts("ON \0");
               //delay_ms(400);
               //lcd_gotoxy(3,1);
              // lcd_puts("  \0");
               //lcd_putint(TastenStatus);
               
               
				}
			}//else
			
		}	// Taste 0
		
         
		
		if (!(TASTENPIN & (1<<TASTE1))) // Taste 1
		{
			//lcd_gotoxy(12,1);
			//lcd_puts("T1 Down\0");
			
			if (! (TastenStatus & (1<<TASTE1))) //Taste 1 war nicht nicht gedrueckt
			{
				TastenStatus |= (1<<TASTE1);
				Tastencount=0;
				//lcd_gotoxy(3,1);
				//lcd_puts("P1 \0");
				//lcd_putint(Servoimpulsdauer);
				//delay_ms(800);
				
			}
			else
			{
				//lcd_gotoxy(3,1);
				//lcd_puts("       \0");
				
				Tastencount +=1;
				if (Tastencount >= Tastenprellen)
				{
					
					
					Tastencount=0;
					TastenStatus &= ~(1<<TASTE1);
					
				}
			}//	else
			
		} // Taste 1
		
		/* ******************** */
		//		initADC(TASTATURPIN);
		//		Tastenwert=(uint8_t)(readKanal(TASTATURPIN)>>2);
		
		Tastenwert=0;
		
		//lcd_gotoxy(3,1);
		//lcd_putint(Tastenwert);
   
		//OSZIBHI;
      if (usbstatus & (1<< USB_SEND))
      {
         //lcd_gotoxy(10,1);
         //lcd_puthex(AbschnittCounter);
         //sendbuffer[3]= AbschnittCounter;
         //usb_rawhid_send((void*)sendbuffer, 50);
         //sendbuffer[0]=0;
         //sendbuffer[5]=0;
         //sendbuffer[6]=0;
         //usbstatus &= ~(1<< USB_SEND);
         
      }

	}//while
   //free (sendbuffer);

// return 0;
}
